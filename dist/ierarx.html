<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Иерархия компонентов в react</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>

<h1>Иерархия компонентов в react</h1>
<p>В React, библиотеке JavaScript для создания пользовательских интерфейсов, иерархия компонентов является фундаментальной концепцией. Приложения React обычно организованы в виде
    дерева компонентов, где каждый компонент представляет часть пользовательского интерфейса. Иерархия необходима для управления состоянием, обработки потоков данных и создания
    модульной и повторно используемой кодовой базы.</p>

<ol>
    <li>
        <h2>Корневой компонент:</h2>
        <p>На вершине иерархии находится корневой компонент, который является отправной точкой вашего приложения React.
            Этот компонент обычно визуализируется с использованием метода ReactDOM.render(). Он инкапсулирует все приложение и может содержать дочерние компоненты.</p>
        <strong>
            <xmp>
                ReactDOM.render(
                <RootComponent/>
                ,
                document.getElementById('root')
                );
            </xmp>
        </strong>

        <p>Однако, существует обычная практика иметь точку входа или корневой файл, в котором метод ReactDOM.render() используется для отображения основного компонента React в
            HTML-документе.</p>

        <p>Эту точку входа часто называют что-то вроде "index.js" или "App.js", и это служит отправной точкой для приложения React. В этом файле вы найдете функцию
            ReactDOM.render(), которая отвечает за рендеринг основного компонента React в DOM. Например:</p>

        <strong>
            <xmp>
                // index.js
                import React from 'react';
                import ReactDOM from 'react-dom';
                import App from './App';

                ReactDOM.render(
                <React.StrictMode>
                    <App/>
                </React.StrictMode>
                ,
                document.getElementById('root')
                );
            </xmp>

            <p>Здесь App находится основной компонент вашего приложения React. ReactDOM.render() Функция принимает этот компонент и преобразует его в HTML-элемент с идентификатором
                'root'.</p>

            <p>Основная функция этого корневого файла - инициировать приложение React путем рендеринга компонента верхнего уровня в DOM. Он устанавливает начальную структуру
                приложения и устанавливает корень дерева компонентов. Дерево компонентов - это иерархическая структура компонентов React, в которой корневым является компонент
                верхнего уровня, содержащий все остальные компоненты.</p>
        </strong>

        <p>jsx из функции может возвращаться через слово return если вы создаете функциональный компонент или из метода render если вы создаете классовый компонент </p>

        <img src="images/img2.jpg" alt="">
        <p>Корневым является div который обернут</p>
    </li>

    <li>
        <h2>Родительские компоненты:</h2>
        <p>Под корневым компонентом у вас есть родительские компоненты, которые представляют различные разделы или основные функции вашего приложения.
            Родительские компоненты могут содержать дочерние компоненты и отвечают за управление состоянием и передачу данных своим дочерним компонентам.</p>

        <strong>
            <xmp>
                function ParentComponent() {
                return (
                <div>
                    <ChildComponent/>
                    <AnotherChildComponent/>
                </div>
                );
                }
            </xmp>
        </strong>

        <p>Родительские компоненты играют решающую роль в структурировании и организации вашего приложения React. Вот несколько ключевых причин, по которым родительские компоненты
            необходимы:</p>
        <ol>
            <li>
                <h3>Композиция и модульность:</h3>
                <p>Родительские компоненты позволяют создавать ваше приложение путем объединения меньших по размеру, повторно используемых дочерних компонентов. Это способствует
                    созданию модульной и поддерживаемой структуры кода.
                    Вы можете инкапсулировать определенную функциональность или фичи в отдельные дочерние компоненты, а затем создавать более сложные пользовательские интерфейсы,
                    объединяя эти более мелкие компоненты в родительском компоненте.</p>
            </li>

            <li>
                <h3>Передача данных:</h3>
                <p>Родительские компоненты могут передавать данные своим дочерним компонентам через props. Это обеспечивает передачу информации от компонента более высокого уровня
                    к его потомкам.
                    Управляя состоянием и передавая его дочерним компонентам, родительские компоненты могут контролировать поведение и внешний вид своих дочерних компонентов.</p>
            </li>

            <li>
                <h3>Управление состоянием:</h3>
                <p>Родительские компоненты часто служат основным местом для управления состоянием в приложении React. Они могут хранить и обновлять данные о состоянии, а затем
                    передавать соответствующие части состояния дочерним компонентам в качестве реквизитов.
                    Управление состоянием в родительских компонентах помогает синхронизировать данные приложения и обеспечивает единый источник достоверности для состояния.</p>
            </li>

            <li>
                <h3>Обработка событий:</h3>
                <p>Родительские компоненты могут определять и обрабатывать события, происходящие в их области видимости. Когда происходит событие, родительский компонент может
                    обновлять свое состояние и, при необходимости, передавать обновленные данные или обратные вызовы дочерним компонентам для запуска дальнейших действий.</p>
            </li>

            <li>
                <h3>Контролируемые компоненты:</h3>
                <p>В контролируемых компонентах, где состояние компонента контролируется родительским компонентом, родительский компонент становится ответственным за управление и
                    обновление состояния своих дочерних компонентов.
                    Такой подход обеспечивает более предсказуемый и контролируемый поток данных и поведение внутри приложения.</p>
            </li>

            <li>
                <p>В целом, родительские компоненты в React играют ключевую роль в организации, управлении состоянием и облегчении взаимодействия между различными частями вашего
                    приложения. Они способствуют сопровождаемости, повторному использованию и масштабируемости вашей базы кода React.</p>
            </li>
        </ol>
    </li>

    <li>
        <h2>Дочерние компоненты:</h2>
        <p>Дочерние компоненты - это компоненты, вложенные в родительские компоненты.
            Они получают данные от своих родительских компонентов через props и также могут иметь свое собственное локальное состояние.
            Дочерние компоненты могут дополнительно содержать свои собственные дочерние компоненты, образуя вложенную структуру.</p>

        <strong>
            <xmp>
                function ChildComponent(props) {
                return (
                <p>{props.message}</p>
                );
                }
            </xmp>
        </strong>

        <p>Дочерние компоненты в React.js являются неотъемлемой частью построения масштабируемых и обслуживаемых пользовательских интерфейсов. Они выполняют несколько важных
            функций, которые вносят вклад в общую структуру, модульность и возможность повторного использования приложения React. Вот несколько ключевых причин, по которым дочерние
            компоненты необходимы:</p>
        <ol>
            <li>
                <h3>Модульность и возможность повторного использования:</h3>
                <p>Дочерние компоненты позволяют разбить ваш пользовательский интерфейс на более мелкие автономные модули. Каждый дочерний компонент может инкапсулировать
                    определенную функциональность или представлять отдельную часть пользовательского интерфейса.
                    Модульность, обеспечиваемая дочерними компонентами, способствует возможности повторного использования кода, упрощая обслуживание и расширение вашего
                    приложения.</p>
                <p>Приложения React часто создаются путем объединения меньших компонентов в более крупные. Дочерние компоненты можно комбинировать и вкладывать в родительские
                    компоненты для создания сложных
                    Такой композиционный подход упрощает общую структуру приложения и</p>
            </li>

            <li>
                <h3>Разделение проблем:</h3>
                <p>Дочерние компоненты помогают разделить задачи в вашем приложении. Каждый компонент может быть сфокусирован на определенном аспекте пользовательского интерфейса
                    или функциональности, что делает кодовую базу более организованной и понятной.
                    Разделение задач также способствует лучшему сотрудничеству между разработчиками, работающими над различными частями приложения.</p>
            </li>

            <li>
                <h3>Инкапсуляция функциональности:</h3>
                <p>Дочерние компоненты могут инкапсулировать определенную функциональность, что упрощает анализ и тестирование отдельных функций изолированно.
                    Разделив свой пользовательский интерфейс на более мелкие, сфокусированные компоненты, вы можете создать четкие границы для каждой функции или поведения, что
                    улучшает код.</p>
            </li>

            <li>
                <h3>Распространение данных (реквизит):</h3>
                <p>Родительские компоненты могут передавать данные дочерним компонентам через props. Это позволяет дочерним компонентам получать и отображать динамическую
                    информацию.
                    Распространение данных через props обеспечивает однонаправленный поток данных, облегчая понимание и отладку процесса передачи информации</p>
            </li>

            <li>
                <h3>Обработка событий:</h3>
                <p>Дочерние компоненты часто обрабатывают взаимодействия с пользователем или события в своей определенной области пользовательского интерфейса. При возникновении
                    события дочерний компонент может запустить функцию обратного вызова, переданную от его родительского элемента, позволяя родительскому элементу ответить
                    Этот механизм обработки событий способствует контролируемому потоку действий и обновлений внутри приложения.</p>

                <p>Разбиение сложного пользовательского интерфейса на более мелкие, управляемые компоненты улучшает читаемость вашего кода. Разработчикам также проще разобраться в
                    нем.
                    Дочерние компоненты способствуют созданию более организованной и модульной базы кода, снижая когнитивную нагрузку при работе над конкретными функциями или
                    устранении проблем.</p>
            </li>
        </ol>

        <p>Таким образом, дочерние компоненты в React вносят свой вклад в модульную конструкцию, возможность повторного использования и ремонтопригодность вашего приложения. Они
            обеспечивают четкое разделение задач, упрощают компоновку компонентов и поддерживают общую организацию.</p>
    </li>

    <li>
        <h2>Функциональные компоненты и компоненты классов:</h2>
        <p>Компоненты в React могут быть как функциональными, так и основанными на классах.
            Функциональные компоненты просты и в основном используются для рендеринга пользовательского интерфейса на основе реквизитов.
            Компоненты класса обладают дополнительными функциями, такими как локальное состояние и методы жизненного цикла.</p>

        <strong>
            <xmp>
                // Functional Component
                const FunctionalComponent = (props) => (
                <p>{props.message}</p>
                );

                // Class Component
                class ClassComponent extends React.Component {
                constructor(props) {
                super(props);
                this.state = {
                // initial state
                };
                }

                render() {
                return (
                <p>{this.props.message}</p>
                );
                }
                }
            </xmp>
        </strong>

        <h2>Зачем нужен компоненты классов в react.js и какова его основная функция</h2>
        <p>В то время как функциональные компоненты с перехватами стали предпочтительным выбором для многих разработчиков React из-за их простоты и гибкости, компоненты
            классов по-прежнему актуальны и имеют свои варианты использования. Вот несколько причин, по которым вам могут понадобиться компоненты класса или вы решите
            использовать их в React.js:</p>
        <ol>
            <li>
                <h3>Устаревший код:</h3>
                <p>Существующие кодовые базы могли быть созданы с использованием компонентов класса, и переход к функциональным компонентам с помощью хуков может потребовать
                    значительных усилий. В таких случаях практическим выбором может быть поддержка и расширение компонентов класса.</p>
            </li>

            <li>
                <h3>Методы жизненного цикла:</h3>
                <p>Компоненты класса предоставляют доступ к методам жизненного цикла, таким как componentDidMount, componentDidUpdate и componentWillUnmount. Эти методы полезны для
                    управления побочными эффектами, подписками и выполнения действий на определенных этапах жизненного цикла компонента.</p>
            </li>

            <li>
                <h3>Обратные вызовы Ref:</h3>
                <p>Компоненты класса предлагают удобный способ работы с ссылками с помощью обратных ссылок (ref={(node) => this.myRef = node}). Хотя функциональные компоненты также
                    поддерживают ссылки, компоненты класса могут быть предпочтительнее в ситуациях, когда логика ссылок более сложная или требуется доступ к методам жизненного
                    цикла.</p>
            </li>

            <li>
                <h3>Свойства класса:</h3>
                <p>Компоненты класса позволяют определять свойства класса, такие как состояние и методы экземпляра. Это может быть полезно в сценариях, где вам нужно управлять
                    сложным локальным состоянием или инкапсулировать поведение внутри компонента.</p>
            </li>

            <li>
                <h3>Местное государственное управление:</h3>
                <p>В то время как функциональные компоненты с перехватами могут управлять локальным состоянием с помощью useState перехватчика, компоненты класса предлагают более
                    традиционный подход к обработке состояния с помощью this.state свойства и this.setState метода.</p>
            </li>

            <li>
                <h3>Пользовательские методы экземпляра:</h3>
                <p>Компоненты класса позволяют определять пользовательские методы экземпляра, которые могут быть полезны для инкапсуляции определенного поведения внутри компонента.
                    В определенных случаях это может привести к созданию более чистого и организованного кода.</p>
            </li>

            <li>
                <h3>Интеграция со сторонними библиотеками:</h3>
                <p>Некоторые библиотеки сторонних производителей или инструменты, связанные с React, могут полагаться на компоненты класса. Если вам необходимо интегрироваться с
                    такими библиотеками, использование компонентов класса может быть более практичным.</p>
            </li>

            <li>
                <h3>Знакомство с Шаблоном:</h3>
                <p>Разработчики, которые больше привыкли к синтаксису, основанному на классах, или имеют опыт объектно-ориентированного программирования, могут счесть компоненты
                    классов более интуитивно понятными и простыми в работе.</p>
            </li>

            <li>
                <h3>Повторное подключение:</h3>
                <p>При использовании react-redux библиотеки для интеграции Redux с React, connect функция часто более плавно работает с компонентами класса. Хотя функциональные
                    компоненты также могут использовать хукеры connect с useDispatch и useSelector, некоторые проекты</p>
            </li>
        </ol>

        <p>Важно отметить, что, по состоянию на ограничение моих знаний в январе 2022 года, функциональные компоненты с хуками считаются современным и рекомендуемым способом
            создания компонентов React. Однако выбор между функциональными компонентами и компонентами класса может зависеть от конкретных требований вашего проекта, знакомства
            вашей команды с различными подходами и существующей кодовой базы. По мере развития React значимость компонентов класса может снижаться, поэтому рекомендуется оставаться
            в курсе последних практик.</p>

        <p>Функциональные компоненты в React.js приобретают все большее значение с появлением перехватчиков React. До появления перехватчиков функциональные компоненты в основном
            использовались для более простых компонентов без состояния. Однако с добавлением хуков функциональные компоненты теперь также могут управлять состоянием и иметь методы
            жизненного цикла, что делает их более мощными и универсальными. Вот несколько причин, по которым функциональные компоненты ценны в React.js:</p>

        <ol>
            <li>
                <h3>Простота и лаконичность:</h3>
                <p>Функциональные компоненты, как правило, более лаконичны и их легче читать, чем компоненты класса. Для них требуется меньше шаблонного кода, что делает их
                    предпочтительным выбором для простых компонентов, которым не требуется управление состоянием или жизненным циклом.</p>
            </li>

            <li>
                <h3>Поддержка Хуков:</h3>
                <p>С введением хуковuseState, useEffect, `useContext) функциональные компоненты теперь могут управлять состоянием и иметь побочные эффекты. Хуки позволяют
                    функциональным компонентам выполнять задачи, которые традиционно ассоциировались с компонентами класса, такие как управление локальным состоянием и
                    взаимодействие с жизненным циклом компонента.</p>
            </li>

            <li>
                <h3>Возможность повторного использования:</h3>
                <p>Функциональные компоненты поощряют более функциональный стиль программирования, что часто приводит к более многократному использованию и составному коду. Вы
                    можете создавать небольшие, сфокусированные функциональные компоненты, которые легко повторно использовать в d</p>
            </li>

            <li>
                <h3>Улучшенная производительность:</h3>
                <p>Функциональные компоненты, как правило, обладают лучшей производительностью, чем компоненты класса. Это связано с тем, что функциональные компоненты не несут
                    накладных расходов на создание i</p>
            </li>

            <li>
                <h3>Упрощенное тестирование:</h3>
                <p>Функциональные компоненты, особенно без состояния, как правило, легче тестировать. Поскольку они полагаются на входные данные через props и выдают выходные
                    данные на основе этих входных данных, модульное тестирование становится простым.</p>
            </li>

            <li>
                <h3>Согласованный Синтаксис:</h3>
                <p>С введениемuseState и useEffect синтаксис функциональных компонентов стал более согласованным с компонентами класса. Это упрощает разработчикам переход между
                    функциональными компонентами и компонентами класса и способствует более унифицированному стилю кодирования.</p>
            </li>

            <li>
                <h3>Хуки Способствуют лучшей организации кода:</h3>
                <p>Хуки способствуют созданию более модульной и организованной структуры кода. Логику с отслеживанием состояния и побочные эффекты можно выделить в отдельные хуки,
                    что способствует более четкому разделению задач внутри ваших компонентов.

                    Концепции функционального программирования, такие как неизменяемость и чистые функции, хорошо согласуются с функциональными компонентами. Это может привести к
                    cle</p>
            </li>

            <li>
                <h3>Улучшенная поддержка новых функций:</h3>
                <p>По мере развития React новые функции и оптимизации часто разрабатываются с учетом функциональных компонентов. Будьте в курсе последних</p>
            </li>

            <li>
                <p>Подводя итог, функциональные компоненты React обеспечивают простоту, возможность повторного использования и повышенную производительность. С добавлением хуков
                    функциональные компоненты теперь могут обрабатывать более сложное управление состоянием и поведением в жизненном цикле, что делает их универсальным и мощным
                    выбором для создания современных приложений React.</p>
            </li>
        </ol>
    </li>

    <li>
        <h2>Конечные компоненты:</h2>
        <p>Конечные компоненты являются самым низким уровнем в иерархии и не имеют дочерних компонентов.
            Они часто отвечают за рендеринг определенных элементов пользовательского интерфейса или за выполнение небольших изолированных задач.</p>
        <strong>
            <xmp>
                function LeafComponent() {
                return (
                <span>Leaf Component</span>
                );
                }
            </xmp>
        </strong>

        <h2>зачем мне нужны конечные компоненты в react? js и какова его основная функция</h2>
        <ol>
            <li>
                <h3>"Конечные компоненты" или "Компоненты терминала", то это компоненты, у которых нет дочерних компонентов в дереве компонентов React. Давайте обсудим, почему эти
                    конечные компоненты ценны.:</h3>
            </li>

            <li>
                <h3>Лист в иерархии компонентов:</h3>
                <p>Конечные компоненты обычно находятся в конце иерархии компонентов, что означает, что они не содержат дочерних компонентов. Они представляют собой наименьшие,
                    наиболее детализированные модули в вашем пользовательском интерфейсе.</p>
            </li>

            <li>
                <h3>Атомарные элементы пользовательского интерфейса:</h3>
                <p>Конечные компоненты часто соответствуют элементарным элементам пользовательского интерфейса, таким как кнопки, текстовые вводы или значки. Эти компоненты
                    инкапсулируют определенную функциональность или представляют собой простой визуальный элемент.</p>
            </li>

            <li>
                <h3>Возможность повторного использования:</h3>
                <p>Создавая небольшие, сфокусированные конечные компоненты, вы повышаете возможность повторного использования. Эти компоненты можно легко повторно использовать в
                    разных частях вашего приложения, обеспечивая единый внешний вид и поведение.</p>
            </li>

            <li>
                <h3>Ремонтопригодность:</h3>
                <p>Конечные компоненты вносят вклад в более удобную в обслуживании кодовую базу. Их легче понять и модифицировать, поскольку они инкапсулируют определенную
                    функциональность или визуальный элемент без сложности управления дочерними компонентами.</p>
            </li>

            <li>
                <h3>Состав компонентов:</h3>
                <p>Конечные компоненты могут быть составлены из более крупных и сложных компонентов. Такой композиционный подход позволяет вам создать свой пользовательский
                    интерфейс, комбинируя более мелкие специализированные компоненты.</p>
            </li>

            <li>
                <h3>Четкое разделение проблем:</h3>
                <p>Конечные компоненты помогают добиться четкого разделения задач. Каждый компонент отвечает за определенный аспект пользовательского интерфейса или
                    функциональности, что делает кодовую базу более модульной и о ней легче рассуждать.</p>
            </li>

            <li>
                <h3>Тестирование:</h3>
                <p>Тестирование конечных компонентов обычно несложно, потому что они часто представляют собой единую изолированную часть функциональности. Эта простота упрощает
                    написание модульных тестов для этих компонентов.</p>
            </li>

            <li>
                <h3>Оптимизация производительности:</h3>
                <p>Конечные компоненты, будучи простыми и сфокусированными, могут способствовать повышению производительности. Они с меньшей вероятностью окажут существенное
                    влияние на рендеринг и могут быть проще оптимизированы.</p>
            </li>

            <li>
                <p>Подводя итог, можно сказать, что, хотя концепция "конечных компонентов" может быть нестандартной в терминологии React, идея наличия конечных компонентов имеет
                    решающее значение для создания масштабируемого и поддерживаемого приложения React. Эти компоненты служат строительными блоками вашего пользовательского
                    интерфейса, обеспечивая возможность повторного использования, ремонтопригодность и четкую структуру в иерархии ваших компонентов.</p>
            </li>
        </ol>
    </li>

    <li>
        <p>Понимание и структурирование ваших компонентов в четкой иерархии имеет решающее значение для создания масштабируемых и обслуживаемых приложений React.
            Иерархия обеспечивает лучшую организацию, возможность повторного использования и простоту понимания потока данных в вашем приложении.</p>
    </li>
</ol>

</body>
</html>
